import JWTObject  from 'tenshi/objects/JWTObject';
import Validations  from 'tenshi/helpers/Validations';
import HttpAction from 'tenshi/helpers/HttpAction';

import ConfigManager  from "tenshi/config/ConfigManager";
import { EntityTarget, RequestHandler } from 'tenshi/generics/index';

import RoleRepository from "tenshi/generics/Role/RoleRepository"
import IGenericRepository from 'tenshi/generics/Repository/IGenericRepository';
import GenericRepository from 'tenshi/generics/Repository/GenericRepository';

import IGenericController from 'tenshi/generics/Controller/IGenericController';
import ControllerObject from 'tenshi/objects/ControllerObject';

import { createControllerObject } from 'tenshi/services/ControllerObjectFactory';

import { ConstHTTPRequest, ConstStatusJson, ConstMessagesJson, ConstRoles, ConstGeneral } from "tenshi/consts/Const";

/*
    This class have the necessary methods (CRUDS) to send into the routing
    You need to send the entity type, the models generated by de TYPE ORM &&
    Then you send the controller object, with all the specific names of the specific entity
    PD: IF YOU NEED TO OVERRIDE OR ADDED MORE METHODS, YOU NEED TO CREATE ANOTHER CONTROLLER AND EXTEND THIS
*/7
export default  class GenericController implements IGenericController{
    private controllerObj: ControllerObject;
    private entityType : EntityTarget<any>;
    private roleRepository : RoleRepository;
    private repository : IGenericRepository;

    /**
     * Constructor of the GenericController class.
     * This class needs the type of the entity of the ORM, and the controller object.
     * @param {EntityTarget<any>} entityType - The type of the entity of the ORM.
     * @param {IGenericRepository | null} repositoryClass - The repository class of the entity.
     *                                                      If it's not passed, a new instance of GenericRepository will be created.
     */
    constructor(entityType: EntityTarget<any>, repositoryClass: IGenericRepository | null = null) {
        // Create the controller object using the entity type.
        this.controllerObj = createControllerObject(entityType);

        // Set the entity type.
        this.entityType = entityType;

        // Get the instance of the RoleRepository.
        this.roleRepository = RoleRepository.getInstance();

        // Check if the repository class is passed.
        // If not, create a new instance of GenericRepository using the entity type.
        // Otherwise, set the repository class.
        if(repositoryClass == null){
            this.repository = new GenericRepository(this.entityType);
        }else{
            this.repository = repositoryClass;
        }
    }
   

    /**
     * Getter and Setters
     */
    public getControllerObj(): ControllerObject {
        return this.controllerObj;
    }

    public getRoleRepository(): RoleRepository {
        return this.roleRepository;
    }

    public getRepository(): IGenericRepository {
        return this.repository;
    }


    /**
     * This function is used to insert a new entity into the database.
     * It performs the following steps:
     * 1. Validates the role of the user.
     * 2. Validates the required fields of the entity.
     * 3. Validates the regex of the entity.
     * 4. Sets the user id of the entity.
     * 5. Inserts the entity into the database.
     * 6. Returns a success response if the insertion is successful.
     * 7. Returns a database error response if there is an error while inserting the entity.
     * 8. Returns a general error response if there is an error while performing the above steps.
     *
     * @param {RequestHandler} reqHandler - The request handler object.
     * @return {Promise<any>} A promise that resolves to the success response if the insertion is successful.
     */
    async insert(reqHandler: RequestHandler): Promise<any> {
        // Execute the returns structure
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
            // Validate the role of the user
            const validation : Validations = reqHandler.getResponse().locals.validation;
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;

            if(await this.validateRole(reqHandler,  jwtData.role, this.controllerObj.create, httpExec) !== true){ return; }

            // Validate the required fields of the entity
            if(!this.validateRequiredFields(reqHandler, validation)){ return; }

            // Validate the regex of the entity
            if(!this.validateRegex(reqHandler, validation)){ return; }

            // Set the user id of the entity
            let body = reqHandler.getAdapter().entityFromPostBody();
            body = this.setUserId(body, jwtData.id);

            try{
                // Insert the entity into the database
                const createdEntity = await this.repository.add(body);

                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(createdEntity), ConstHTTPRequest.INSERT_SUCESS);

            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }
  

     /**
      * Update an entity in the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the updated entity.
      */
     async update(reqHandler: RequestHandler): Promise<any> {
        // Execute the returns structure
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            // Validate the role of the user
            const validation : Validations = reqHandler.getResponse().locals.validation;
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            if (await this.validateRole(reqHandler, jwtData.role, this.controllerObj.update, httpExec) !== true) {
                return;
            }

            // Validate the regex of the entity
            if (!this.validateRegex(reqHandler, validation)) {
                return;
            }

            // Get the id from the URL params
            const id = this.getIdFromQuery(validation, httpExec) as number;

            // If you need to validate if the user id of the table 
            // should be the user id of the user request (JWT)
            await this.validateUserIdByIdOrCodeEntity(reqHandler, httpExec, jwtData, id);

            // Get data from the body
            const body = reqHandler.getAdapter().entityFromPutBody();

            try {
                // Execute the update action in the database
                const updateEntity = await this.repository.update(id, body,
                                                             reqHandler.getLogicalDelete());
                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(updateEntity), ConstHTTPRequest.UPDATE_SUCCESS);

            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }

        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }

     /**
      * Delete an entity from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the deleted entity.
      */
     async delete(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
            // Get the validations object from the response
            const validation : Validations = reqHandler.getResponse().locals.validation;
            // Get the JWT object from the response
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
            // Get the id from URL params
            const id =  (this.getIdFromQuery(validation, httpExec) as number); 

            // Validate the role of the user
            if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.delete, httpExec) !== true){ return; }
            // Validate the user id
            await this.validateUserIdByIdOrCodeEntity(reqHandler, httpExec, jwtData, id);

            try{
                // Execute the delete action in the database
                if(reqHandler.getLogicalDelete()){
                    // Logically remove the entity from the database
                    const deletedEntity = await this.repository.logicalRemove(id);
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(deletedEntity), ConstHTTPRequest.DELETE_SUCCESS);
                }else{
                    // Remove the entity from the database
                    const deletedEntity = await this.repository.remove(id);
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(deletedEntity), ConstHTTPRequest.DELETE_SUCCESS);
                }
                
            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }

     /**
      * Get an entity by its ID from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the entity.
      */
     async getById(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
             // Get the validations object from the response
             const validation : Validations = reqHandler.getResponse().locals.validation;
             // Get the JWT object from the response
             const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
             // Get the id from URL params
             const id =  (this.getIdFromQuery(validation, httpExec) as number); 

             // Validate the role of the user
             if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec) !== true){ return; }
             // Validate the user id
             await this.validateUserIdByIdOrCodeEntity(reqHandler, httpExec, jwtData, id);

            try{
                // Execute the get by id action in the database
                const entity = await this.repository.findById(id, reqHandler.getLogicalDelete());
                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(entity), ConstHTTPRequest.GET_BY_ID_SUCCESS);

            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }


     /**
      * Get an entity by its code from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the entity.
      */
     async getByCode(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
             // Get the validations object from the response
             const validation : Validations = reqHandler.getResponse().locals.validation;
             // Get the JWT object from the response
             const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
             // Get the code from URL params
             const code = this.getCodeFromQuery(validation, httpExec) as string;

             // Validate the role of the user
             if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec) !== true){ return; }
             // Validate the user id
             await this.validateUserIdByIdOrCodeEntity(reqHandler, httpExec, jwtData, code);

            try{
                // Execute the get by code action in the database
                const entity = await this.repository.findByCode(code, reqHandler.getLogicalDelete());
                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(entity), ConstHTTPRequest.GET_BY_ID_SUCCESS);

            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }
   

    /**
     * Retrieves all entities from the database.
     *
     * @param reqHandler - The request handler.
     * @returns A promise that resolves to the entities.
     */
    async getAll(reqHandler: RequestHandler): Promise<any> {
        const config = ConfigManager.getInstance().getConfig();
        // Get the HTTP action object from the response
        const httpExec: HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            const jwtData: JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            if (await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getAll, httpExec) !== true) {
                return;
            }

            try {
                // Get the page and size from the URL query parameters
                const page: number = reqHandler.getRequest().query.page ?
                    parseInt(reqHandler.getRequest().query.page as string) :
                    config.HTTP_REQUEST.PAGE_OFFSET;

                const size: number = reqHandler.getRequest().query.size ?
                    parseInt(reqHandler.getRequest().query.size as string) :
                    config.HTTP_REQUEST.PAGE_SIZE;

                // Execute the get all action in the database
                const entities = await this.repository.findAll(reqHandler.getLogicalDelete(), page, size);

                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entitiesToResponse(entities), ConstHTTPRequest.GET_ALL_SUCCESS);
            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(),
                    reqHandler.getMethod(), this.controllerObj.controller);
            }
        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
    }
  

    /**
     * This function gets entities by applying filters specified in the request parameters.
     * 
     * @param {RequestHandler} reqHandler - The request handler object.
     * @returns {Promise<any>} A promise that resolves to the success response if the operation is successful.
     */
    async getByFilters(reqHandler: RequestHandler): Promise<any> {
        const config = ConfigManager.getInstance().getConfig();
        // Get the HTTP action object from the response
        const httpExec: HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            // Get the JWT data from the response
            const jwtData: JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec);

            // Check if filters are provided in the request parameters
            if (reqHandler.getFilters() == null) {
                return httpExec.paramsError(); // Return error response if filters are not provided
            }

            try {
                // Get the page and size from the URL query parameters
                const page: number = reqHandler.getRequest().query.page ?
                    parseInt(reqHandler.getRequest().query.page as string) :
                    config.HTTP_REQUEST.PAGE_OFFSET;

                const size: number = reqHandler.getRequest().query.size ?
                    parseInt(reqHandler.getRequest().query.size as string) :
                    config.HTTP_REQUEST.PAGE_SIZE;

                // Execute the find by filters action in the database
                const entities = await this.repository.findByFilters(reqHandler.getFilters()!,
                    reqHandler.getLogicalDelete(), page, size);

                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entitiesToResponse(entities), ConstHTTPRequest.GET_ALL_SUCCESS);

            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(),
                    reqHandler.getMethod(), this.controllerObj.controller);
            }
        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
    }

    


     /**
      * This function validates the role of the user.
      * 
      * @param {RequestHandler} reqHandler - The request handler object.
      * @param {string} role - The role of the user.
      * @param {string} action - The action to be performed.
      * @param {HttpAction} httpAction - The HTTP action object.
      * @return {Promise<any>} - A promise that resolves to the result of the validation.
      */
     protected async validateRole(reqHandler: RequestHandler, role: string, action: string,  httpAction: HttpAction): Promise<any> {
        /**
         * Validates the role of the user.
         * If the user's role is required to be validated, it checks if the user has the permission for the specified action.
         * If the user does not have the permission, it returns an unauthorized error.
         * 
         * @returns {Promise<any>} A promise that resolves to the result of the validation.
         */
        if(reqHandler.getRoleValidation()){
            // Get the permission for the specified action and role from the role repository.
            const roleFunc = await this.roleRepository.getPermissionByFuncAndRole(role, action);
            // If the user does not have the permission, return an unauthorized error.
            if (roleFunc == null) {
                return httpAction.unauthorizedError(ConstMessagesJson.ROLE_AUTH_ERROR);
            }
        }

        return true;
    }

    /**
     * Validates the required fields of the body JSON.
     * 
     * @param {RequestHandler} reqHandler - The request handler object.
     * @param {Validations} validation - The validations object.
     * @return {boolean} - Returns true if all the required fields are present, false otherwise.
     */
    protected validateRequiredFields(reqHandler: RequestHandler, validation: Validations): boolean {
        // Check if the required fields list is not null
        if (reqHandler.getRequiredFieldsList() != null) {
            // Validate the required fields
            if (!validation.validateRequiredFields(reqHandler.getRequiredFieldsList())) {
                // If any of the required fields are missing, return false
                return false;
            }
        }

        // If all the required fields are present, return true
        return true;
    }

    /**
     * Validates the regex of any fields.
     * It checks if the request handler object contains a list of regex validators.
     * If it does, it validates the multiple regex using the validation object.
     * 
     * @param {RequestHandler} reqHandler - The request handler object.
     * @param {Validations} validation - The validations object.
     * @returns {boolean} - Returns true if all the regex validations pass, false otherwise.
     */
    protected validateRegex(reqHandler: RequestHandler, validation: Validations): boolean {
        // Check if the request handler object contains a list of regex validators
        if (reqHandler.getRegexValidatorList() != null) {
            // Validate the multiple regex using the validation object
            if (validation.validateMultipleRegex(reqHandler.getRegexValidatorList()) != null) {
                // If any of the regex validations fail, return false
                return false;
            }
        }

        // If all the regex validations pass, return true
        return true;
    }

    /**
     * Sets the user ID in the body object if the ID is not present.
     * This function checks if the user ID is present in the body object.
     * If it is not present, it sets the user ID with the provided ID.
     *
     * @param {any} body - The body object containing the user ID
     * @param {number} id - The ID to set in the user ID field if it is not present in the body object
     * @return {any} - The modified body object with the user ID field set
     */
    protected setUserId(body: any, id: number): any {
        // Check if the user ID is not present in the body object
        if (!(ConstGeneral.USER_ID in body)) {
            // If the user ID is not present, set the user ID with the provided ID
            body.userId = id;
        }

        // Return the modified body object with the user ID field set
        return body;
    }
   
    /**
     * Validates the user ID by ID or code entity.
     * This function checks if the request handler object requires validation of the where clause by user ID.
     * If it does, it checks the role of the JWT and sets the user ID accordingly.
     * Then, it calls the appropriate entity retrieval function based on the type of the ID or code.
     * Finally, it checks if the entity exists and if the user ID of the entity is different from the user ID of the JWT.
     * If any of these conditions are not met, it returns an unauthorized error.
     *
     * @async
     * @param {RequestHandler} reqHandler - The request handler object.
     * @param {HttpAction} httpExec - The HTTP action object.
     * @param {JWTObject} jwtData - The JWT object.
     * @param {number | string} idOrCode - The ID or code of the entity.
     * @return {Promise<any>} - Returns a promise that resolves to the result of the HTTP action object.
     */
    protected async validateUserIdByIdOrCodeEntity(reqHandler: RequestHandler, httpExec: HttpAction, jwtData: JWTObject, idOrCode: number | string) {
        let userId: number | null = null; // Initialize user ID

        // Check if the request handler object requires validation of the where clause by user ID
        if (reqHandler.getRequireValidWhereByUserId()) {
            // Check if the role of the JWT is not admin
            if (jwtData.role != ConstRoles.ADMIN) {
                userId = jwtData.id; // Set the user ID with the ID of the JWT
            }

            // Call the appropriate entity retrieval function based on the type of the ID or code
            let entity: any = null; // Initialize entity
            if (typeof idOrCode === 'number') {
                entity = await this.repository.findById(idOrCode, reqHandler.getLogicalDelete()); // Call findById function
            } else {
                entity = await this.repository.findByCode(idOrCode, reqHandler.getLogicalDelete()); // Call findByCode function
            }

            // Check if the entity exists and if the user ID of the entity is different from the user ID of the JWT
            if (entity != undefined && entity != null ) {
                if(jwtData.role != ConstRoles.ADMIN){
                    if (userId != null && entity.userId != userId) {
                        return httpExec.unauthorizedError(ConstMessagesJson.ROLE_AUTH_ERROR); // Return unauthorized error if conditions are not met
                    }
                }
            } else {
                return httpExec.dynamicError(ConstStatusJson.NOT_FOUND, ConstMessagesJson.DONT_EXISTS); // Return dynamic error if entity does not exist
            }
        }
    }
  
    /**
     * Retrieves the ID from the query parameters.
     * 
     * @param {Validations} validation - The validation object.
     * @param {HttpAction} httpExec - The HTTP action object.
     * @return {number | null} - The ID from the query parameters or null if validation fails.
     */
    protected getIdFromQuery(validation: Validations, httpExec: HttpAction){
        // Validate the ID from the query parameters
        const id = validation.validateIdFromQuery();

        // If the ID is null (validation failed), return a parameter error
        if(id == null){
            return httpExec.paramsError();
        }

        // Return the ID from the query parameters
        return id;
    }
 

    /**
     * Retrieves the code from the query parameters.
     * 
     * @param {Validations} validation - The validation object.
     * @param {HttpAction} httpExec - The HTTP action object.
     * @return {string | null} - The code from the query parameters or null if validation fails.
     */
    protected getCodeFromQuery(validation: Validations, httpExec: HttpAction){
        // Validate the code from the query parameters
        const code = validation.validateCodeFromQuery();

        // If the code is null (validation failed), return a parameter error
        if(code == null){
            // Return a parameter error
            return httpExec.paramsError();
        }

        // Return the code from the query parameters
        return code;
    }
  
}